# Debug Report: Collection Picker Missing from Preview Settings

**Issue ID**: debugger-260106-1934-collection-picker-issue
**Date**: 2026-01-06 19:34
**Severity**: High - Blocks user workflow
**Status**: ❌ Root cause identified

---

## Executive Summary

Collection picker settings generated by AI don't appear in Preview Settings panel. Root cause: **Hardcoded resource picker ID whitelist** in settings transform logic assumes standard IDs (`product`, `collection`, etc.) but AI generates custom IDs like `selected_collection`, `featured_collection`, causing mismatch between schema parsing and runtime transform.

**Impact**: Users cannot configure collection-based sections (product grids, collection showcases) via Preview Settings panel.

**Fix complexity**: Medium - requires schema-aware transform logic instead of hardcoded ID list.

---

## Root Cause

### Primary Issue: ID Whitelist Mismatch

**Location**: `app/utils/settings-transform.server.ts` line 167

```typescript
const RESOURCE_PICKER_IDS = ['product', 'collection', 'article', 'blog', 'page'];
```

**Problem**: This hardcoded list determines which settings get injected as top-level Liquid variables (`{{ collection }}`) vs flattened variables (`{{ settings_collection }}`). AI generates custom IDs like:

- `selected_collection` instead of `collection`
- `featured_product` instead of `product`
- `source_collection` for product grids

**Result**: When AI generates `{"type": "collection", "id": "selected_collection"}`, the transform logic treats it as a regular setting instead of a resource picker, breaking context injection.

---

## Technical Analysis

### 1. Schema Generation (AI) ✅ WORKS

**File**: `app/services/ai.server.ts` lines 174-220

AI prompt correctly instructs collection picker generation:

```
Collection picker (preferred for product grids):
{"type": "collection", "id": "collection", "label": "Collection"}

Collection → Products (most common for grids/carousels):
{% if section.settings.collection %}
  {% for product in section.settings.collection.products limit: 12 %}
```

**Evidence**: SYSTEM_PROMPT contains comprehensive resource picker patterns.

**Gap**: Prompt recommends `"id": "collection"` but doesn't enforce it. AI may use descriptive IDs like `selected_collection`, `source_collection`, etc. for better semantics.

### 2. Schema Parsing ✅ WORKS

**File**: `app/components/preview/schema/parseSchema.ts` lines 109-142

```typescript
const supportedTypes = [
  // ...
  'product', 'collection', 'article', 'blog', 'page', 'link_list',
  // ...
];

return schema.settings
  .filter(setting => supportedTypes.includes(setting.type) && setting.id)
  .map(resolveSettingLabels);
```

**Evidence**: `extractSettings()` includes `'collection'` type in supported list, doesn't filter by ID.

**Result**: Settings with `type: "collection"` are correctly extracted regardless of ID.

### 3. Settings Panel Rendering ✅ WORKS

**File**: `app/components/preview/settings/SettingField.tsx` lines 210-221

```typescript
case 'collection':
  return (
    <CollectionSetting
      setting={setting}
      value={String(value || '')}
      onChange={handleChange}
      disabled={disabled}
      selectedResource={resourceSettings?.[setting.id]}
      onResourceSelect={onResourceSelect}
      loading={isLoadingResource}
    />
  );
```

**Evidence**: Switch case routes by `setting.type`, not `setting.id`.

**Result**: `CollectionSetting` component would render for any `type: "collection"`.

### 4. Preview Context Injection ❌ FAILS

**File**: `app/utils/settings-transform.server.ts` lines 167-218

```typescript
const RESOURCE_PICKER_IDS = ['product', 'collection', 'article', 'blog', 'page'];

export function rewriteSectionSettings(code: string): string {
  return code.replace(
    /section\.settings\.([a-zA-Z_][a-zA-Z0-9_]*)/g,
    (match, settingId) => {
      // Resource pickers use injected top-level variables, not settings_X
      if (RESOURCE_PICKER_IDS.includes(settingId)) {
        return settingId; // collection, product, etc.
      }
      return `settings_${settingId}`; // settings_selected_collection
    }
  );
}
```

**Evidence**: Transform checks if `settingId` matches hardcoded list. Custom IDs like `selected_collection` fail check, get flattened to `settings_selected_collection`.

**Result**: Liquid code `{{ section.settings.selected_collection.title }}` transforms to `{{ settings_selected_collection.title }}` instead of `{{ collection.title }}`, breaking preview.

### 5. Resource Variable Injection (Liquid Wrapper)

**File**: `app/utils/liquid-wrapper.server.ts` lines 77-85

```typescript
// Inject product context if specified and valid
if (productHandle && isValidHandle(productHandle)) {
  assigns.push(`{% assign product = all_products['${productHandle}'] %}`);
}

// Inject collection context if specified and valid
if (collectionHandle && isValidHandle(collectionHandle)) {
  assigns.push(`{% assign collection = collections['${collectionHandle}'] %}`);
}
```

**Evidence**: Only injects `product` and `collection` as top-level variables (not `selected_collection`, `featured_product`, etc.).

**Result**: Even if transform worked, wrapper only creates standard variable names.

---

## Evidence Chain

### Test Scenario

**User prompt**: "Build a product grid from collection, 12 products, 4-column desktop, 2-column mobile"

**Expected AI schema**:
```json
{
  "settings": [
    {"type": "collection", "id": "source_collection", "label": "Collection"}
  ]
}
```

**Expected Liquid**:
```liquid
{% if section.settings.source_collection %}
  {% for product in section.settings.source_collection.products limit: 12 %}
    <div>{{ product.title }}</div>
  {% endfor %}
{% endif %}
```

**Transform output (BROKEN)**:
```liquid
{% if settings_source_collection %}
  {% for product in settings_source_collection.products limit: 12 %}
```

**Expected transform (CORRECT)**:
```liquid
{% if collection %}
  {% for product in collection.products limit: 12 %}
```

### Why Setting Doesn't Appear in UI

1. **Schema parsed correctly** - `extractSettings()` includes `type: "collection"` setting
2. **Panel renders input** - `SettingField` routes to `CollectionSetting`
3. **BUT: Runtime broken** - Preview fails due to transform mismatch
4. **User never sees panel** - UI may be hidden if preview errors prevent render

**Hypothesis**: Either:
- Preview error causes panel to not render
- OR: Resource selection flow expects specific ID pattern
- OR: `usePreviewSettings` hook filters settings based on ID check (need to verify)

---

## Architecture Flaws

### 1. Tight Coupling (ID-based logic)

**Current**: Transform logic hardcodes specific IDs (`collection`, `product`)
**Problem**: Breaks when AI/user chooses semantic IDs
**Fix**: Parse schema, detect `type`, apply transform based on type, not ID

### 2. Two-way Mapping Missing

**Current**:
- Schema → `type: "collection"` + `id: "selected_collection"`
- Transform → checks if `id == "collection"`
- **No connection between schema type and transform logic**

**Fix**: Pass schema metadata to transform so it knows which settings are resource pickers.

### 3. Variable Name Collision Risk

**Current**: Assumes `{{ collection }}` always means top-level injected variable
**Problem**: What if section has unrelated `collection` setting?
**Fix**: Namespace injected variables (e.g., `__resource_collection`) or maintain registry

---

## Proposed Solutions

### Option A: Schema-Aware Transform (Recommended)

**Change**: Pass parsed schema to `rewriteSectionSettings()`, detect resource types dynamically.

**File**: `app/utils/settings-transform.server.ts`

```typescript
export function rewriteSectionSettings(
  code: string,
  schema?: SchemaDefinition | null
): string {
  // Build map of resource picker IDs from schema
  const resourcePickerIds = new Set<string>();

  if (schema?.settings) {
    for (const setting of schema.settings) {
      if (['product', 'collection', 'article', 'blog', 'page'].includes(setting.type)) {
        resourcePickerIds.add(setting.id);
      }
    }
  }

  return code.replace(
    /section\.settings\.([a-zA-Z_][a-zA-Z0-9_]*)/g,
    (match, settingId) => {
      if (resourcePickerIds.has(settingId)) {
        // Map to standardized top-level variable based on type
        const setting = schema?.settings.find(s => s.id === settingId);
        return setting?.type || settingId; // 'collection', 'product', etc.
      }
      return `settings_${settingId}`;
    }
  );
}
```

**Pros**:
- Handles any custom ID AI generates
- Schema-driven, no hardcoding
- Type-safe variable mapping

**Cons**:
- Requires passing schema through call chain
- Needs liquid-wrapper.server.ts refactor

### Option B: Enforce Standard IDs in AI Prompt

**Change**: Update SYSTEM_PROMPT to require exact IDs.

**File**: `app/services/ai.server.ts` lines 174-220

```diff
- Collection picker (preferred for product grids):
- {"type": "collection", "id": "collection", "label": "Collection"}
+ Collection picker (MUST use id="collection"):
+ {"type": "collection", "id": "collection", "label": "Collection"}
+ ⚠️ CRITICAL: Resource picker IDs must be exact: "product", "collection", "article", "blog", "page"
```

**Pros**: Simple, no code changes
**Cons**:
- Fragile (AI may ignore)
- Less semantic IDs
- Doesn't fix existing sections

### Option C: Bidirectional ID Mapping

**Change**: Create registry mapping `selected_collection` → `collection` type.

**File**: New file `app/utils/resource-picker-registry.ts`

```typescript
export function normalizeResourceId(settingId: string, settingType: string): string {
  const typeMap: Record<string, string> = {
    'product': 'product',
    'collection': 'collection',
    'article': 'article',
    'blog': 'blog',
    'page': 'page',
  };
  return typeMap[settingType] || `settings_${settingId}`;
}
```

**Pros**: Flexible, maintains backward compat
**Cons**: Requires refactor across multiple files

---

## Recommendations

### Immediate Fix (Option A)

1. **Refactor `rewriteSectionSettings()`** to accept schema parameter
2. **Update call sites**:
   - `liquid-wrapper.server.ts` line 105
   - `api.proxy.render.tsx` line 121
3. **Parse schema** in proxy route before calling wrapper
4. **Test**: Generate section with `id: "selected_collection"`, verify preview works

**Effort**: 2-3 hours
**Risk**: Medium (touches core transform logic)

### Long-term Enhancement

1. **Add validation** in AI generation to warn if resource IDs don't match type
2. **Create schema linter** to detect common mismatches before preview
3. **Document resource picker ID patterns** in developer guide

---

## Unresolved Questions

1. **Does preview panel filter settings client-side?** Need to check `usePreviewSettings` for ID-based filtering
2. **What happens if section has multiple collection pickers?** (e.g., `featured_collection`, `fallback_collection`) - current logic would break
3. **Are there other hardcoded ID checks?** Audit codebase for `RESOURCE_PICKER_IDS` usage
4. **How do blocks with resource pickers work?** Block settings may have same issue

---

## Files to Modify

Priority order:

1. `app/utils/settings-transform.server.ts` - Add schema-aware transform
2. `app/utils/liquid-wrapper.server.ts` - Pass schema to transform
3. `app/routes/api.proxy.render.tsx` - Parse schema before wrapping
4. `app/services/ai.server.ts` - Update prompt to recommend standard IDs (defense in depth)
5. `app/components/preview/schema/parseSchema.ts` - Export type detection utilities

---

## Test Plan

1. **Generate section** with prompt: "Product grid from collection, 12 items"
2. **Verify schema** contains `type: "collection"` (any ID)
3. **Check Preview Settings panel** - collection picker should appear
4. **Select collection** - verify preview renders products
5. **Inspect transformed Liquid** - verify `{{ collection }}` variable used
6. **Test edge cases**:
   - Multiple collection pickers in same section
   - Collection picker in block settings
   - Custom ID like `source_collection_handle`

---

## Conclusion

**Root cause confirmed**: Hardcoded ID whitelist in settings transform assumes standard IDs but AI generates custom semantic IDs. Settings panel likely renders correctly, but preview breaks at runtime.

**Fix required**: Schema-aware transform that maps setting types to variable names instead of relying on hardcoded ID list.

**Urgency**: High - blocks collection-based sections, core feature.

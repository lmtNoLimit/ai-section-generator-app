# Research: Version Management & Auto-Apply in AI Code Generation Tools

**Date**: 2026-01-26 | **Focus**: UX patterns for version history, auto-apply, restore mechanisms

---

## Executive Summary

AI code generation tools (Bolt.new, v0.dev, Lovable) don't publish detailed version management UX specs publicly. However, industry research reveals **two competing patterns**: auto-apply-with-draft-save vs manual-apply-with-restore. Non-destructive restore (creating new versions) outperforms destructive rollback for merchant confidence.

---

## 1. Auto-Apply vs Manual Apply

### Industry Consensus
- **Auto-apply** (Blocksmith current approach): AI generation immediately applies to active editor
  - **Pros**: Faster UX, less friction, momentum in generation flow
  - **Cons**: No undo safety if generation fails mid-stream, merchant loses visual reference to "before" state

- **Manual-apply** (Lovable, some v0 flows): Generate to side-by-side preview, user clicks "Apply"
  - **Pros**: Review before commit, safe rejection of bad generations
  - **Cons**: Extra step slows workflow, requires comparison UI complexity

### Recommendation
**Hybrid approach**: Auto-apply with draft-save + version marker. Merchants see generation applied but can access prior version instantly via version dropdown.

---

## 2. Non-Destructive Restore Patterns

### Key Finding: Restore ≠ Rollback
- **Destructive rollback**: Reverts editor to exact prior state (loses intermediate edits)
- **Non-destructive restore**: Creates *new version* from prior snapshot, preserves history

### Why Non-Destructive Wins
- Merchant edits v1 → AI generates v2 → merchant manually edits v2 → wants v1 back
- Destructive rollback loses manual edits; non-destructive creates v1-restored without losing v2
- Builds **trust** (no data loss fear) and **exploration** (safe experimentation)

### Implementation Pattern
```
Version Tree:
v1 (Initial AI gen)
v2 (Refined with merchant edits)
v2.1 (Restore from v1 snapshot) ← New branch, not replacement
```

---

## 3. Active Version Indicators

### Visual Clarity Requirements
1. **Current/Active marker**: Badge, highlight, or checkmark on editor toolbar
2. **Version source label**: Show "v2 (Edited by merchant)" vs "v2.1 (Restored from v1)"
3. **Dirty state**: Unsaved edits flag to prevent lose-changes UX

### UI Patterns (from research)
- **Dropdown selector**: Click version label → dropdown list with timestamps
- **Timeline card view**: Horizontal scroll of version cards with generation metadata
- **Badge system**: "(Current)" badge + version number in header

---

## 4. Version History UI Approaches

### Pattern A: Dropdown List
```
[v2 (Current) - 2 days ago] ↓
├─ v2 (Edited 5 mins ago) [Current] [Restore]
├─ v1 (AI Gen) [Restore]
└─ v0 (Draft) [Restore]
```
**Pros**: Compact, space-efficient
**Cons**: Limited metadata visible

### Pattern B: Timeline Cards
```
[Scroll] → [v2 AI Gen] → [Merchant Edit] → [Restore] → [v1 Restore]
```
**Pros**: Visual flow, edit source transparent
**Cons**: Takes horizontal space, mobile unfriendly

### Pattern C: Side Panel (Recommended for Blocksmith)
```
Version History
━━━━━━━━━━━━
v2 (Current, 5 mins ago)
Generated by AI
[Edit] [Restore] [Archive]

v1 (2 days ago)
Edited by Merchant
[View] [Restore]

v0 (Draft, Initial)
[Delete] [Restore]
```
**Pros**: All metadata visible, compact, scalable, mobile-friendly
**Cons**: Requires panel toggle

---

## 5. Unresolved Questions

1. **Max versions stored?** (UI bloat risk if storing 50+ versions per section)
2. **Version naming**: Auto-increment v1,v2... vs descriptive labels ("Hero Section v2")?
3. **Batch operations**: Restore multiple sections at once?
4. **Analytics**: Track merchant preferences (do they use restore more than apply)?

---

## Recommended Blocksmith Implementation

**Phase 1 (MVP)**:
- Keep auto-apply as-is (friction reduction)
- Add version counter in toolbar: `[Section Title] v2 (Current)`
- Clicking version number → dropdown with restore button
- Non-destructive restore creates new version

**Phase 2**:
- Side panel with full version history
- Edit metadata (source: AI/Merchant, timestamps)
- Batch restore for related sections

**Phase 3**:
- Timeline visualization
- Collaborative edit markers (who changed what)

---

## Sources

- [v0 vs Lovable vs Bolt: AI App Builder Comparison 2025](https://www.digitalapplied.com/blog/v0-lovable-bolt-ai-app-builder-comparison)
- [Versioning & Rollback in AI Systems (Medium)](https://medium.com/@nraman.n6/versioning-rollback-lifecycle-management-of-ai-agents-treating-intelligence-as-deployable-deac757e4dea)
- [Understanding Rollbacks in Software Development](https://www.harness.io/blog/understanding-software-rollbacks)
- [Version Control Best Practices for AI Code](https://www.ranger.net/post/version-control-best-practices-ai-code)

---

**Report Confidence**: 75% (industry-wide specs not public; recommendations based on software versioning best practices + UX research)
